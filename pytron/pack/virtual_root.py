import ast
import os
import re
from pathlib import Path
from typing import List, Set
from ..console import log


class VirtualRootGenerator:
    """
    Scans the codebase for 'app.expose' and generates a
    Virtual Entry Point (VEP) that acts as the minimal root for the dependency graph.
    """

    def __init__(self, source_dir: Path):
        self.source_dir = source_dir
        self.exposed_functions = []  # List of (module_name, function_name)

    def scan(self):
        """
        Recursively scans .py files for app.expose usages.
        """
        log("Scanning for exposed API endpoints...", style="cyan")

        # We need to map file paths to module names relative to source_dir
        for root, _, files in os.walk(self.source_dir):
            for file in files:
                if file.endswith(".py"):
                    full_path = Path(root) / file
                    self._scan_file(full_path)

        log(f"Found {len(self.exposed_functions)} exposed endpoints.", style="info")

    def _scan_file(self, file_path: Path):
        try:
            content = file_path.read_text(encoding="utf-8", errors="ignore")

            # Simple Text/Regex Heuristic (Robust against AST failures)
            # Pattern 1: @app.expose or @expose
            # Pattern 2: app.expose(func_name)

            # 1. Decorator Scan
            # This is hard because we need the function name AFTER the decorator.
            # So we use AST because it's safer for structure.
            tree = ast.parse(content)

            # Calculate module name
            rel_path = file_path.relative_to(self.source_dir)
            module_parts = list(rel_path.parts)
            module_parts[-1] = module_parts[-1].replace(".py", "")
            if module_parts[-1] == "__init__":
                module_parts.pop()
            module_name = ".".join(module_parts)

            for node in ast.walk(tree):
                # Check for Decorators
                if isinstance(node, ast.FunctionDef):
                    is_exposed = False
                    for dec in node.decorator_list:
                        # Check @app.expose
                        if isinstance(dec, ast.Attribute) and dec.attr == "expose":
                            is_exposed = True
                        # Check @expose direct import
                        elif isinstance(dec, ast.Name) and dec.id == "expose":
                            is_exposed = True

                    if is_exposed:
                        self.exposed_functions.append((module_name, node.name))

                # Check for manual calls: app.expose(my_func)
                elif isinstance(node, ast.Call):
                    if (
                        isinstance(node.func, ast.Attribute)
                        and node.func.attr == "expose"
                    ):
                        # Look at arguments
                        if node.args:
                            arg = node.args[0]
                            if isinstance(arg, ast.Name):
                                # app.expose(my_func)
                                self.exposed_functions.append((module_name, arg.id))

        except Exception as e:
            # log(f"Warning: Failed to parse {file_path.name}: {e}", style="dim")
            pass

    def generate(self, output_path: Path) -> Path:
        """
        Generates the _virtual_root.py file.
        """
        lines = [
            "# VIRTUAL ENTRY POINT generated by Pytron Crystal",
            "# This file imports all exposed functions to force-load their dependencies.",
            "",
            "import sys",
            "import pytron",
            "",
            "# --- EXPOSED ENDPOINTS ---",
        ]

        # Sort for determinism
        self.exposed_functions.sort()

        used_modules = set()

        for mod, func in self.exposed_functions:
            lines.append(f"from {mod} import {func}")
            used_modules.add(mod)

        lines.append("")
        lines.append(f"# Total Exposed Functions: {len(self.exposed_functions)}")
        lines.append("")

        # Add a main block that mimics the app startup
        lines.append("if __name__ == '__main__':")
        lines.append("    print('[VEP] Virtual Entry Point Loaded.')")
        lines.append("    # This script does nothing but import variables.")
        lines.append(
            "    # The act of importing is what triggers the dependency loading."
        )

        output_path.write_text("\n".join(lines), encoding="utf-8")
        log(f"Generated Virtual Entry Point: {output_path.name}", style="success")
        return output_path
